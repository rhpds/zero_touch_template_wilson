= Container Configuration Basics
:estimated-time: 15-20 minutes

== Learning Outcomes

Upon completion, you will understand:

* Basic container deployment with port and network configuration
* Container resource configuration (memory, CPU, storage)
* Container service exposure through routes for external access
* Container security best practices and troubleshooting

== Overview

Containers provide lightweight, fast-starting services perfect for databases, web applications, and development tools. This guide teaches fundamental container deployment patterns in Zero Touch labs.

== Basic Container Configuration

[%collapsible]
====
Add containers to your `config/instances.yaml` file:

.Basic Container Configuration <<template-instances>>
[source,yaml]
----
---
containers: []
# Note: Official template has no containers by default
# Add containers here as needed for your lab
----

== Container Configuration Parameters

[cols="1,1,3"]
|===
|Parameter |Required |Description

|`name`
| Yes
|Unique container identifier

|`image`
| Yes
|Container image (Docker Hub format)

|`ports`
|No
|List of exposed ports

|`environment`
|No
|Environment variables

|`memory`
|No
|Memory limit (default: "32Mi")

|`cpu`
|No
|CPU limit (default: 1)

|`command`
|No
|Override container command

|`volumeMounts`
|No
|Mount persistent storage
|===

== Common Container Examples

=== Redis Cache

[source,yaml]
----
- name: "redis-cache"
  image: "redis:7-alpine"
  memory: "256Mi"
  cpu: "0.5"
  ports:
    - name: redis
      containerPort: 6379
      protocol: TCP
  environment:
    REDIS_PASSWORD: "{{ common_password }}"
----

=== PostgreSQL Database  

[source,yaml]
----
- name: "postgres-db"
  image: "postgres:15"
  memory: "1G" 
  cpu: "1"
  ports:
    - name: postgres
      containerPort: 5432
      protocol: TCP
  environment:
    POSTGRES_DB: "labdb"
    POSTGRES_USER: "labuser"
    POSTGRES_PASSWORD: "{{ common_password }}"
  volumes:
    - name: "postgres-data"
      emptyDir: {}
  volumeMounts:
    - name: "postgres-data"
      mountPath: "/var/lib/postgresql/data"
----

=== Web Application

[source,yaml]
----
- name: "webapp"
  image: "nginx:latest"
  memory: "128Mi"
  ports:
    - name: http
      containerPort: 80
      protocol: TCP
  volumes:
    - name: "webapp-config"
      configMap:
        name: "nginx-config"
  volumeMounts:
    - name: "webapp-config"
      mountPath: "/etc/nginx/conf.d"
----

== Container Networking

Containers automatically get:
* **Internal DNS**: Access via container name (e.g., `redis-cache`)
* **Network connectivity**: Can connect to VMs and other containers
* **Internet access**: For downloading packages and updates

[IMPORTANT]
====
**SSH Access Limitation**: By default, containers **cannot SSH to VMs** due to network policies.

If your container needs SSH access to VMs (like for development tools, monitoring, etc.), you must configure network policies. See xref:network-policy-configuration.adoc[Network Policy Configuration] for details.

**Symptoms**: SSH connections timeout or are refused from containers.
====

=== Connecting from VMs

From your VMs, access containers by name:

[source,bash]
----
# Connect to Redis from a VM
redis-cli -h redis-cache -p 6379

# Connect to PostgreSQL
psql -h postgres-db -U labuser -d labdb

# Test web application  
curl http://webapp
----

== Environment Variables

Pass configuration to containers:

[source,yaml]
----
- name: "app-server"
  image: "node:18-alpine"
  environment:
    NODE_ENV: "development"
    DATABASE_URL: "postgres://labuser:{{ common_password }}@postgres-db/labdb"
    REDIS_URL: "redis://redis-cache:6379"
    API_KEY: "{{ common_password }}"
----

== Combining VMs and Containers

Create hybrid environments:

[source,yaml]
----
---
virtualmachines:
  - name: "app-server"
    image: "rhel-9.6"
    cores: 2
    memory: "4G"
    
containers:
  - name: "database"
    image: "postgres:15"
    memory: "1G"
    environment:
      POSTGRES_PASSWORD: "{{ common_password }}"
    ports:
      - name: postgres
        containerPort: 5432
        protocol: TCP
      
  - name: "cache"
    image: "redis:7-alpine"
    memory: "256Mi"
    ports:
      - name: redis
        containerPort: 6379
        protocol: TCP
----

From the VM, connect to containers:

[source,bash]
----
# Install database client
dnf install -y postgresql

# Connect to containerized database
psql -h database -U postgres
----

== Resource Management

Set appropriate limits:

[source,yaml]
----
- name: "resource-limited-app"
  image: "nginx:latest"
  memory: "128Mi"        # Memory limit
  cpu: "0.5"            # CPU limit (0.5 cores)
----

## Testing Containers

Verify container functionality:

[source,bash]
----
# From a VM or bastion, test container connectivity
curl http://webapp
redis-cli -h redis-cache ping
nc -zv postgres-db 5432
----

== Best Practices

=== Resource Allocation
* **Start small**: Begin with minimal memory/CPU
* **Monitor usage**: Check container performance
* **Set limits**: Prevent resource exhaustion

=== Security
* **Use variables**: Never hardcode passwords
* **Latest images**: Keep container images updated
* **Minimal images**: Use alpine versions when possible

=== Networking
* **DNS names**: Use container names for connectivity  
* **Port planning**: Avoid port conflicts
* **Service discovery**: Leverage automatic DNS

== Troubleshooting

**Container won't start?**
→ Check image name and resource limits

**Can't connect to container?**
→ Verify port configuration and DNS name

**Out of resources?**  
→ Reduce container memory limits

== Next Steps

Choose your learning path:

**Practice Hands-On:**
* xref:module-2-5-containers-deep-dive.adoc[**Module 2.5: Containers Deep Dive**] - Build multi-container applications step-by-step

**Expand Container Knowledge:**
* xref:container-advanced.adoc[**Advanced Container Configuration**] - Overview of advanced patterns and specialized topics
* xref:container-multi-service-patterns.adoc[**Multi-Service Container Patterns**] - Deploy complete application stacks

**Integrate with Other Components:**
* xref:networking-basics.adoc[**Networking Basics**] - Connect containers to custom networks and VMs
* xref:network-policy-configuration.adoc[**Network Policy Configuration**] - Configure SSH access between containers and VMs

**Production Ready:**
* xref:container-monitoring-logging.adoc[**Container Monitoring & Logging**] - Implement observability
* xref:container-testing-validation.adoc[**Container Testing & Validation**] - Ensure reliability

== Related Documentation

* xref:vm-basics.adoc[VM Configuration Basics] - Set up VMs alongside containers
* xref:firewall-basics.adoc[Firewall Configuration Basics] - Secure your container deployments  
* xref:template-customization-guide.adoc[Template Customization Guide] - Integrate containers into complete lab designs
====

[bibliography]
== References

* [[[template-instances]]] Red Hat GPTE Team. Zero Touch Template Instance Configuration. 
  `https://github.com/rhpds/lab_zero_touch_template.git` - config/instances.yaml. 2024.

* [[[roadshow-instances]]] Red Hat Ansible Team. AAP 2.5 Roadshow Lab Instance Configuration. 
  AgnosticV Git Repository - zt-ans-bu-roadshow01/config/instances.yaml. 2024.

* [[[agnosticd-base]]] Red Hat GPTE Team. AgnosticD Zero Touch Base RHEL Configuration. 
  AgnosticD Git Repository - ansible/configs/zero-touch-base-rhel/default_vars_openshift_cnv.yaml. 2024.
